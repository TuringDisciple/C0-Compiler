#![allow(non_snake_case)]
use lexer::lexer::*;
use std::vec::Vec;
use std::result;

/*
The purpose of the parser is to apply semantic meaning to our language lexemes.
Our parser must therefore perform the following functions

1. Construct semantically correct structures from lexems following the language grammar
2. Identify syntactic errors in source


Fortunately there is a formal grammar specification
for the C0 language. The problems with this grammar is that
it's left recursive which will introduce complications with parsing down the line.
 */

enum Exp{
    Id(Vec<Token>),
}

#[derive(Clone)]
pub struct Parser {
    tokens: VecDeque<Token>,
    head: Option(Token),
    ast: Vec<Exp>
}
impl Parser {
    pub fn new(file_path: &mut String) -> Parser {
        let tokens = Lexer::new(file_path).lexer.tokens();
        let head = tokens.pop_front();
        Parser {
            tokens,
            head,
            ast: Vec::new(),
        }
    }

    fn eat(&mut self, t: Token) -> Result<Token, ()>{

        let compare = |l: Token, r: Token| -> Result<Token, ()> {
            if l == r {
                self.head = self.tokens.pop_front();
                Ok(l)
            } else {
                Err(())
            }
        }; 

        match self.head {
            Some(h) =>{
                match (h, t) {
                    (Token::Undefined(_), Token::Undefined(_)) |
                    (Token::Num(_), Token::Num(_)) => {
                        self.head = self.tokens.pop_front();
                        Ok(h)
                    },
                    (_, _) => compare(h, t),
            },
            _ => Err(()),
        }
    }
    // <id> ::= [A-Za-z_][A-Za-z0-9_]*
    pub fn parseId(&mut self){
        loop {
            
        }
    }
}




